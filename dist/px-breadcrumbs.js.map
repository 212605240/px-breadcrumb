{"version":3,"sources":["px-breadcrumbs.es6.js"],"names":["Polymer","is","properties","breadcrumbData","type","Array","value","mainPathItems","computed","_clickItem","Object","_clickedItemChildren","_isDropdownHidden","Boolean","_normalizePathClickTarget","evt","target","_iconsetName","parentNode","_computeMainPath","currentDataObj","pathArray","recursiveLoopThroughObj","pathItem","i","length","children","push","selectedItem","_doesItemHaveChildren","itemInPath","hasChildren","_isNotLastItemInData","index","_calculatePathclass","_onPathTap","dataItem","model","item","stopPropagation","set","normalizedTarget","targetRect","getBoundingClientRect","targetLeft","left","targetBottom","bottom","targetHeight","height","windowScrollX","window","scrollX","windowScrollY","scrollY","dropdown","dom","root","querySelector","console","log","style","top","extractClickedPathItemPosition","clickedItem","changeDropdownPosition","positioning","_notifyClick","dispatchEvent","CustomEvent","composed"],"mappings":"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","file":"px-breadcrumbs.js","sourcesContent":["(function() {\n  Polymer({\n\n    is: 'px-breadcrumbs', \n\n    properties: {\n      /**\n       * This array receives/holds the data that will be transformed into the breadcrumbs.\n       */\n      breadcrumbData: {\n        type: Array,\n        value: function() {return [];}\n      },\n      mainPathItems: {\n        type: Array,\n        value: function() {return [];},\n        computed: '_computeMainPath(breadcrumbData)'\n      },\n      _clickItem: {\n        type: Object,\n        value: function() {return {};}\n      },\n      _clickedItemChildren: {\n        type: Array,\n        value: function() {return [];},\n        \n      },\n      _isDropdownHidden: {\n        type: Boolean,\n        value: true\n      }\n    },\n    /**\n     * This method is used to determine where the path click came from - we have 3 different options, \n     * 1. the text\n     * 2. the down chevron\n     * 3. The side chevron\n     * but we really want the encompossing LI, regardless of what was clicked. \n     * the two icons have a _iconsetName property that is 'fa' so we use that to determine if they were clicked, \n     * and if so, grab their parent, which is the LI.\n     * @param {*} evt the event generated by the user tap\n     */\n    _normalizePathClickTarget(evt) {\n      return (evt.target._iconsetName === 'fa') ? evt.target.parentNode.parentNode : evt.target;\n    },\n    _computeMainPath(currentDataObj) {\n      var pathArray = [];\n      // if (currentDataObj.children) {\n      //   PathArray.push(currentDataObj)\n      // }\n      var recursiveLoopThroughObj = function(pathItem) {\n        for (var i=0; i<pathItem.length;i++) {\n          if (pathItem[i].children) {\n            pathArray.push(pathItem[i]);\n            recursiveLoopThroughObj(pathItem[i].children)\n          } else {\n            if (pathItem[i].selectedItem) {\n              pathArray.push(pathItem[i]);\n            }\n          }\n        }\n      };\n      recursiveLoopThroughObj(currentDataObj);\n      return pathArray;\n    },\n    /**\n     * This function checks whether the item in question has children.\n     * @param {*} itemInPath \n     */\n    _doesItemHaveChildren(itemInPath) {\n      return itemInPath.hasChildren;\n    },\n    /**\n     * This function is used to determine whether we are on the last Item in the array. - if \n     * the index is the last item in the aray (length -1), we return false.\n     * @param {*} index \n     */\n    _isNotLastItemInData(index) {\n      return this.mainPathItems.length-1 !== index;\n    },\n    /**\n     * This function is used to determine the correct classes that need to be passed in - if \n     * the index is the last item in the aray, we want it to be bold, so we pass the selected class.\n     * \n     * @param {*} index This represents the index of the item we are looking at in the array.\n     */\n    _calculatePathclass(index) {\n      return !this._isNotLastItemInData(index) ?  ' selected' : '';\n    },\n    _onPathTap(evt) {\n      var dataItem = evt.model.item;\n      /* on tap, we need to find out if the clicked item is the same as before.\n      * if it is, we make the dropdown go way.\n      * if it is not, we save the new clicked item.\n      */\n\n      // if the selected item (the one at the end of the breadcrumb) has been clicked, ignore it.\n      if (evt.model.item.selectedItem) {\n        evt.stopPropagation();\n        return;\n      }\n      if (this._clickItem === evt.model.item) {\n        this.set('_isDropdownHidden', true);\n        this.set('_clickItem', {});\n      } else {\n        this.set('_clickItem', dataItem);\n        this.set('_isDropdownHidden', false);\n      }\n      // 1. Check if there are children. \n\n      if (this._doesItemHaveChildren(dataItem)) {\n        this.set('_clickedItemChildren', dataItem.children);\n      }\n      var normalizedTarget = this._normalizePathClickTarget(evt),\n          targetRect = normalizedTarget.getBoundingClientRect(),\n          targetLeft = targetRect.left,\n          targetBottom = targetRect.bottom,\n          targetHeight = targetRect.height,\n          windowScrollX = window.scrollX,\n          windowScrollY = window.scrollY,\n          dropdown = Polymer.dom(this.root).querySelector('.breadCrumbdropdown');\n      console.log(targetRect);\n      dropdown.style.top = (targetBottom + windowScrollY + 4) + 'px';\n      dropdown.style.left = targetLeft + windowScrollX + 'px';\n      \n        // a. If there are kids, we need to update clickedItemChildren. \n        // b. If not, we fire an event that the clicked on item is the selected context.\n      // 2. If there are children, we need to find the left/top/height of the clicked item, and calculate the positioning of the dropdown accordingly \n    },\n    \n    /**\n     * \n     * @param {Object} clickedItem the clicked item\n     * @return Object that holds the calculated top/left for the dropdown.\n     */\n    extractClickedPathItemPosition(clickedItem) {\n      //TODO extract top/left/height from clickedItem.\n      // then, calculate the new positioning, and save it into an object.\n      // returns an object that holds the new top/left positioning.\n    },\n    /**\n     * \n     * @param {Object} positioning an object which holds the new positioning for the dropdown\n     */\n    changeDropdownPosition(positioning) {\n      //TODO find out if we are hitting the window edge. \n      //if we aren't, change the position of the dropdown to be under the clicked item\n      //if we are, have smart positioning, \n    },\n    /**\n     * This method dispatches a custom event ('px-breadcrumbs-item-clicked') that has the item attached to it.\n     * the 'composed: true' property makes it so the event passes through shadow dom boundaries.\n     * @param {*} item the item that was clicked on.\n     */\n    _notifyClick(item) {\n      //TODO fire an event with the clicked on item.\n      this.dispatchEvent(new CustomEvent('px-breadcrumbs-item-clicked', {item: item, composed: true}));\n    }\n  });\n})();\n"]}