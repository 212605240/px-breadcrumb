{"version":3,"sources":["px-breadcrumbs.es6.js"],"names":["Polymer","is","properties","breadcrumbData","type","Array","value","_mainPathItems","_clickPathItem","Object","_clickedItemChildren","_isDropdownHidden","Boolean","_selectedItem","created","async","_createCanvas","observers","prepareData","_calculatePath","then","pathArray","_breadcrumbsDisplayOptions","set","_calculateSizeOfBreadcrumbs","strArray","map","useFullSize","ctx","i","length","item","get","thingToMeasure","text","truncatedText","sizeOfItem","parseInt","measureText","width","children","_calculateAcummSize","items","requiredParam","reduce","accum","index","Promise","accept","reject","WeakMap","accumulativeSizeOfAllBreadcrumbs","breadcrumbs","document","querySelector","breadcrumbsContainer","dom","root","breadcrumbsUlContainer","bcUlContainerRect","getBoundingClientRect","ulWidth","_shortenLongAssetNames","sizeOfAllButLastItem","slice","beginningItems","lastItem","preparePromise","shortenedAllButTheLastItems","sizeOfLastItem","allButTheLastItem","result","size","resolve","shortenAllItems","sizeOfAllShortenedItem","shortenAllItemsWithOverflow","overflowArray","removedItem","shift","push","console","log","overflowObj","unshift","canvas","createElement","height","_measurementCanvas","getContext","font","len","_returnShortenString","itemText","beginning","subitemText","middle","end","_normalizePathClickTarget","evt","target","_iconsetName","parentNode","_resetSelectedItem","currentDataObj","self","foundSelectedItem","recursiveLoopThroughObj","pathItem","selectedItem","_doesItemHaveChildren","itemInPath","hasChildren","_isLastItemInData","_calculatePathclass","_dropdownTap","newSelectItem","model","_setSelectedItem","_changePathFromDropdownClick","_onPathTap","dataItem","stopPropagation","_changeDropdownPosition","normalizedTarget","targetRect","targetLeft","left","targetBottom","bottom","targetHeight","windowScrollX","window","scrollX","windowScrollY","scrollY","dropdown","style","top","_notifyClick","dispatchEvent","CustomEvent","composed"],"mappings":"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","file":"px-breadcrumbs.js","sourcesContent":["(function() {\n  Polymer({\n\n    is: 'px-breadcrumbs', \n\n    properties: {\n      /**\n       * This array receives/holds the data that will be transformed into the breadcrumbs.\n       */\n      breadcrumbData: {\n        type: Array,\n        value: function() {return [];}\n      },\n      _mainPathItems: {\n        type: Array,\n        value: function() {return [];}\n      },\n      _clickPathItem: {\n        type: Object,\n        value: function() {return {};}\n      },\n      _clickedItemChildren: {\n        type: Array,\n        value: function() {return [];},\n        \n      },\n      _isDropdownHidden: {\n        type: Boolean,\n        value: true\n      },\n      _selectedItem: {\n        type: Object,\n        value: function() {return {};}\n      }\n    },\n    // attached() {\n    //   this.prepareData();\n    // },\n    created() {\n      this.async(() => {\n        this._createCanvas();\n      });\n    },\n    observers: ['prepareData(_selectedItem)'],\n    /**\n     * This method has a chain of promises that process the data as needed.\n     * first, we find the selected item inside _calculatePath\n     * secondly, we set the _mainPathItems\n     * thirdly, we figure out the display options - whether we need overflow, shorten any names, etc.\n     * lastly, we set the _mainPathItems again, this time with the shortened/overflow version, \n     * if necessary\n     */\n    prepareData() {\n      this._calculatePath()\n      .then((pathArray) => {\n        return this._breadcrumbsDisplayOptions(pathArray)})\n      .then((pathArray) => {\n        //and the second time this is being set, it's with the shortened versions, if necessary. \n        this.set('_mainPathItems', pathArray);\n      });\n    },\n    _calculateSizeOfBreadcrumbs(strArray, map, useFullSize=true) {\n      if (strArray) {\n        var ctx = this.ctx;\n\n        for (var i=0; i<strArray.length;i++) {\n          var item = map.get(strArray[i]) || {};\n          var thingToMeasure = useFullSize ? strArray[i].text : item.truncatedText;\n          //console.log(parseInt(ctx.measureText(strArray[i].text).width,10));\n          var sizeOfItem = parseInt(ctx.measureText(thingToMeasure).width,10);\n\n          //if the item has children, we need to the size of the down chevron.\n          if (strArray[i].children) {\n            sizeOfItem += 11;\n          }\n\n          item[useFullSize ? 'fullSize' : 'truncatedSize'] = sizeOfItem;\n          map.set(strArray[i], item); \n        }\n      }        \n        \n      return map;\n    },\n\n    _calculateAcummSize(items, map, requiredParam) {\n        return items.reduce((accum, item, index) => {\n          if (index !== items.length -1) {\n            accum += 15;\n          }\n          return accum + map.get(item)[requiredParam];\n        },0);\n    },\n    /* \n    * in this method, we decide on the display options for the breadcrumbs. \n    * we have the following options:\n    * 1. we can shorten all but the last one, and see if they fit\n    * 2. we can shorten all including the last one and see if they fit\n    * 3. we can shorten all of them, and include the overflow at the beginning of the array.\n    * @param {array} strArray an array of objects, which contains the breadcrumbs\n    */\n    _breadcrumbsDisplayOptions(strArray) {\n      return new Promise((accept, reject) => {\n        var ctx = this.ctx,\n            map = new WeakMap(),\n            accumulativeSizeOfAllBreadcrumbs;\n\n        map = this._calculateSizeOfBreadcrumbs(strArray, map, true);\n        \n        accumulativeSizeOfAllBreadcrumbs = this._calculateAcummSize(strArray, map, 'fullSize');\n\n         \n          this.async(() => {\n            var breadcrumbs = document.querySelector('px-breadcrumbs'),\n                breadcrumbsContainer = Polymer.dom(breadcrumbs.root).querySelector('.container'),\n                breadcrumbsUlContainer = Polymer.dom(breadcrumbsContainer).querySelector('ul'),\n                bcUlContainerRect = breadcrumbsContainer.getBoundingClientRect(),\n                ulWidth = bcUlContainerRect.width + 4; //the 4 is for the padding on the ul.\n\n               \n            // we check to see if the container (which is sized automatically to fill out the page)\n            // can fit all the items in the breadcrumbs.\n            //the first option is the simpliest one - everything just fits, but if it doesn't fit...\n            if (ulWidth < accumulativeSizeOfAllBreadcrumbs) {\n\n              map = this._shortenLongAssetNames(strArray, map);\n\n              sizeOfAllButLastItem = this._calculateAcummSize(strArray.slice(0, strArray.length-1), map, false);\n\n              var beginningItems = strArray.slice(0, strArray.length-1);\n              var lastItem = strArray.slice(-1);\n              var preparePromise = () => {\n                var shortenedAllButTheLastItems, sizeOfAllButLastItem, sizeOfLastItem;\n                this._shortenLongAssetNames(allButTheLastItem)\n                  .then((result) => {\n                    shortenedAllButTheLastItems = result;\n                    return this._calculateSizeOfBreadcrumbs(shortenedAllButTheLastItems);\n                  })\n                  .then((size) => {\n                    sizeOfAllButLastItem = size;\n                    return this._calculateSizeOfBreadcrumbs(lastItem);\n                  })\n                  .then((size) => {\n                    sizeOfLastItem = size;\n                    return Promise.resolve({sizeOfLastItem, sizeOfAllButLastItem, shortenedAllButTheLastItems});\n                  });\n              }\n\n              preparePromise.then(({sizeOfLastItem, sizeOfAllButLastItem, shortenedAllButTheLastItems}) => {\n                //we want to find out if the container can now fit all of the shortened items + the last Item + 26 (11 for bottom chevron, 15 for side angle) for the last item, that wasn't shortened\n              if (ulWidth < sizeOfAllButLastItem + sizeOfLastItem + 26) {\n                //it doesn't fit, so, we go to second option.\n              \n                var shortenAllItems = this._shortenLongAssetNames(strArray),\n                    sizeOfAllShortenedItem = this._calculateSizeOfBreadcrumbs(shortenAllItems);\n                \n                //we check if we can fit after we've shortened all the items\n                if (ulWidth < sizeOfAllShortenedItem) {\n                  //looks like we can't fit them, even after shortening them all. \n                  //time for option 3.\n                  //i'm setting a random high number to start with\n                  var shortenAllItemsWithOverflow = 99999,\n                      overflowArray = [],\n                      removedItem;\n                  //keep looping until all the items fit into the container\n                  while (ulWidth < shortenAllItemsWithOverflow + lastItem + 26) {\n                    //we remove the first item - mutating strArray, and returning the item\n                    //which then gets pushed into overflowArray, giving us an array of the items we\n                    //had to cut out once this loop is done.\n                    removedItem = allButTheLastItem.shift();\n                    //console.log(removedItem);\n                    overflowArray.push(removedItem);\n                    console.log(overflowArray);\n                    shortenAllItemsWithOverflow = this._calculateSizeOfBreadcrumbs(allButTheLastItem);\n                  }\n                  var overflowObj = {\n                    \"text\": \"...\",\n                    \"children\": overflowArray\n                  }\n                  \n                  //this pushes the overflowObj to the beginning of the array.\n                  allButTheLastItem.unshift(overflowObj);\n                  \n                  allButTheLastItem.push(strArray.slice(-1)[0]);\n                  console.log('shorten everything, include overflow');\n                  return accept(allButTheLastItem);\n                } else {\n                  console.log('shorten everything fits');\n                  //we can fit all the breadcrumbs once we've shortened them.\n                  return accept(shortenAllItems);\n              }\n              } else {\n              //shortening everything but the last one works, so we \n              //re-add the last item - unshortened - to the array , and return that.\n              var lastItem = strArray.slice(strArray.length-1);\n              if (allButTheLastItem) {\n                allButTheLastItem.push(lastItem[0]);\n              }\n              console.log('shorten everything but the last one.');\n              return accept(allButTheLastItem);\n            }\n              });\n              \n              \n            \n          } else {\n            //everything fits, no need to shorten anything\n            console.log('everything fits off the bat');\n            return accept(strArray);\n          }\n        }, 1500); \n      });\n    },\n    _createCanvas() {\n      var canvas = document.createElement('canvas');\n      canvas.height = 20;\n      canvas.width = 9999;\n      this._measurementCanvas = canvas;\n      var ctx = this._measurementCanvas.getContext('2d');\n      ctx.font = \"15px GE Inspira Sans\";\n      this.set('ctx', ctx) ;\n    },\n    /**\n     * This method accepts the path array, and loops through it recursively\n     * looking for anything with more than 16 characters.\n     * \n     * once it finds a long asset name, it shortens it.\n     * @param {Object} pathArray \n     * @return {Array} PathArray  - the modified array with the shortened names in it.\n     */\n    _shortenLongAssetNames(pathArray, map) {\n\n      //loop through each item\n        for (var i=0, len = pathArray.length; i<len;i++) {\n\n            var item = map.get(pathArray[i]) || {};\n\n            //either save the shortened version, or the full version of the text\n            item.truncatedText = (pathArray[i].text.length > 16) ? this._returnShortenString(pathArray[i].text) : pathArray[i].text;\n            \n            map.set(pathArray[i], item);\n\n          //make sure to search through the children as well by calling this recursively\n          if (pathArray[i].children) {\n            this._shortenLongAssetNames(pathArray[i].children, map);\n          }\n      }\n      //once we're done, return with the modified map\n      return map;\n       \n    },\n    /**\n     * This method accepts an obj that has more than 16 characters in its text, and \n     * returns the shortened version of that text.\n     * @param {Obj} pathItem \n     * @return {Promise} shortenedString\n     */\n    _returnShortenString(itemText) {\n        var beginning = itemText.subitemText(0,6),\n        middle = \"...\",\n        end = itemText.subitemText(itemText.length-6);\n        return beginning + middle + end;\n    },\n    /**\n     * This method is used to determine where the path click came from - we have 3 different options, \n     * 1. the text\n     * 2. the down chevron\n     * 3. The side chevron\n     * but we really want the encompossing LI, regardless of what was clicked. \n     * the two icons have a _iconsetName property that is 'fa' so we use that to determine if they were clicked, \n     * and if so, grab their parent, which is the LI.\n     * @param {*} evt the event generated by the user tap\n     */\n    _normalizePathClickTarget(evt) {\n      return (evt.target._iconsetName === 'fa') ? evt.target.parentNode.parentNode : evt.target;\n    },\n    /**\n     * This method resets the existing _selectedItem\n     */\n    _resetSelectedItem() {\n      this.set('_selectedItem', false);\n    },\n    /**\n     * This method is called on load, to calculate the initial Path, \n     * everytime a breadcrumb is clicked.\n     * it recursively builds the path, and returns it as a promise.\n     */\n    _calculatePath() {\n      return new Promise((accept, reject) => {\n        var pathArray = [],\n        currentDataObj = this.breadcrumbData,\n        self = this,\n        foundSelectedItem = false;\n        var recursiveLoopThroughObj = function(pathItem) {\n          for (var i=0, len = pathItem.length; i<len;i++) {\n            if (foundSelectedItem) {\n              break;\n            };\n\n            if (pathItem[i].selectedItem) {\n                pathArray.push(pathItem[i]);\n                foundSelectedItem = true;\n                break;\n              }\n\n            if (pathItem[i].children) {\n              //if it has children, we want to keep digging in\n              //so we push the item we are on into the pathArray\n              //and call ourselves with the children of the current item\n              pathArray.push(pathItem[i]);\n              recursiveLoopThroughObj(pathItem[i].children)\n            }\n          }\n        };\n\n        //the initial call into the recursion\n        recursiveLoopThroughObj(currentDataObj);\n\n        //once all the recursion is done, we can return the pathArray\n        return accept(pathArray);\n      });\n    },\n   \n    /**\n     * This function checks whether the item in question has children.\n     * @param {*} itemInPath \n     */\n    _doesItemHaveChildren(itemInPath) {\n      return (itemInPath && itemInPath.hasChildren);\n    },\n    /**\n     * This function is used to determine whether we are on the last Item in the array. - if \n     * the index is the last item in the aray (length -1), we return false.\n     * @param {Number} index the index of the item\n     */\n    _isLastItemInData(index) {\n      return this._mainPathItems[this._mainPathItems.length-1] === this._mainPathItems[index];\n    },\n    /**\n     * This function is used to determine the correct classes that need to be passed in - if \n     * the index is the last item in the aray, we want it to be bold, so we pass the selected class.\n     * \n     * @param {Number} index This represents the index of the item we are looking at in the array.\n     */\n    _calculatePathclass(index) {\n      return this._isLastItemInData(index) ? ' selected' : '';\n    },\n    /**\n     * this method calls a reset on whatever selected Item we \n     * previously had, and calls a set on the new selectedItem \n     * @param {Object} evt the click event from the dropdown item clicked\n     */\n    _dropdownTap(evt) {\n      this._resetSelectedItem();\n      var newSelectItem = evt.model.item;\n      this._setSelectedItem(newSelectItem);\n      //this hides the dropdown\n      this.set('_isDropdownHidden', true);\n      this._changePathFromDropdownClick();\n      //and this clears out the field that hold the previously clicked\n      //path item.\n      this.set('_clickPathItem', {});\n      \n    },\n    /**\n     * This method calls the prepareData method, which runs through the \n     */\n    _changePathFromDropdownClick() {\n      this.prepareData();\n    },\n    /**\n     * This method sets a _selectedItem from the passed object.\n     * @param {Object} selectedItem the new selected item\n     */\n    _setSelectedItem(selectedItem) {\n      selectedItem.selectedItem = true;\n      this.set('_selectedItem', selectedItem);\n    },\n    _onPathTap(evt) {\n      var dataItem = evt.model.item;\n\n      /* on tap, we need to find out if the clicked item is the same as before.\n      * if it is, we make the dropdown go way.\n      * if it is not, we save the new clicked item.\n      */\n\n      // if the selected item (the one at the end of the breadcrumb) has been clicked, ignore it.\n      if (evt.model.item.selectedItem) {\n        evt.stopPropagation();\n        return;\n      }\n      //if the item that is clicked is the open option, hide the dropdown, and reset the _clickPathItem object.\n      if (this._clickPathItem === dataItem) {\n        this.set('_isDropdownHidden', true);\n        this.set('_clickPathItem', {});\n      } else {\n        //new click on new item, set the clicked item, show the dropdown and set its position.\n        this.set('_clickPathItem', dataItem);\n        this.set('_isDropdownHidden', false);\n        this._changeDropdownPosition(evt);\n      }\n      if (this._doesItemHaveChildren(dataItem)) {\n        //dataItem.children = shortenedVersion(dataItem.children)\n        this.set('_clickedItemChildren', dataItem.children);\n      }\n    },\n    /**\n     * @param {Object} positioning an object which holds the new positioning for the dropdown\n     */\n    _changeDropdownPosition(evt) {\n      var normalizedTarget = this._normalizePathClickTarget(evt),\n          targetRect = normalizedTarget.getBoundingClientRect(),\n          targetLeft = targetRect.left,\n          targetBottom = targetRect.bottom,\n          targetHeight = targetRect.height,\n          windowScrollX = window.scrollX,\n          windowScrollY = window.scrollY,\n          dropdown = Polymer.dom(this.root).querySelector('.breadCrumbdropdown');\n      \n      dropdown.style.top = (targetBottom + windowScrollY + 4) + 'px';\n      dropdown.style.left = targetLeft + windowScrollX + 'px';\n    },\n    /**\n     * This method dispatches a custom event ('px-breadcrumbs-item-clicked') that has the item attached to it.\n     * the 'composed: true' property makes it so the event passes through shadow dom boundaries.\n     * @param {*} item the item that was clicked on.\n     */\n    _notifyClick(item) {\n      this.dispatchEvent(new CustomEvent('px-breadcrumbs-item-clicked', {item: item, composed: true}));\n    }\n  });\n})();\n"]}