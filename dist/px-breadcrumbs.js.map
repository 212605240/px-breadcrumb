{"version":3,"sources":["px-breadcrumbs.es6.js"],"names":["Polymer","is","properties","breadcrumbData","type","Array","value","_mainPathItems","_clickPathItem","Object","_clickedItemChildren","_isDropdownHidden","Boolean","_selectedItem","created","async","_createCanvas","observers","prepareData","_calculatePath","then","pathArray","_breadcrumbsDisplayOptions","set","_calculateSizeOfBreadcrumbs","strArray","map","useFullSize","ctx","i","length","item","get","thingToMeasure","text","shortText","sizeOfItem","parseInt","measureText","width","children","_calculateAcummSize","items","requiredParam","reduce","accum","index","Promise","accept","reject","WeakMap","accumulativeSizeOfAllBreadcrumbs","breadcrumbs","document","querySelector","breadcrumbsContainer","dom","root","breadcrumbsUlContainer","bcUlContainerRect","getBoundingClientRect","ulWidth","allButTheLastItem","slice","_shortenLongAssetNames","sizeOfAllButLastItem","sizeOfFullLastItem","fullSize","sizeOfShortLastItem","shortSize","sizeOfAllShortenedItems","shortenAllItemsWithOverflow","pointer","removedItem","currentAccumSize","removedAccumSize","removedSize","overflowObj","_getSmallStrs","slicedStrArray","concat","console","log","strArrayShortened","strArrayShortenedWithFullLastItem","itemList","canvas","createElement","height","_measurementCanvas","getContext","font","len","_returnShortenString","itemText","beginning","substr","middle","end","_normalizePathClickTarget","evt","target","_iconsetName","parentNode","_resetSelectedItem","currentDataObj","self","foundSelectedItem","recursiveLoopThroughObj","pathItem","selectedItem","push","_doesItemHaveChildren","itemInPath","hasChildren","_isLastItemInData","_calculatePathclass","_dropdownTap","newSelectItem","model","_setSelectedItem","_changePathFromDropdownClick","_onPathTap","dataItem","stopPropagation","_changeDropdownPosition","normalizedTarget","targetRect","targetLeft","left","targetBottom","bottom","targetHeight","windowScrollX","window","scrollX","windowScrollY","scrollY","dropdown","style","top","_notifyClick","dispatchEvent","CustomEvent","composed"],"mappings":"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","file":"px-breadcrumbs.js","sourcesContent":["(function() {\n  Polymer({\n\n    is: 'px-breadcrumbs', \n\n    properties: {\n      /**\n       * This array receives/holds the data that will be transformed into the breadcrumbs.\n       */\n      breadcrumbData: {\n        type: Array,\n        value: function() {return [];}\n      },\n      _mainPathItems: {\n        type: Array,\n        value: function() {return [];}\n      },\n      _clickPathItem: {\n        type: Object,\n        value: function() {return {};}\n      },\n      _clickedItemChildren: {\n        type: Array,\n        value: function() {return [];},\n        \n      },\n      _isDropdownHidden: {\n        type: Boolean,\n        value: true\n      },\n      _selectedItem: {\n        type: Object,\n        value: function() {return {};}\n      }\n    },\n    // attached() {\n    //   this.prepareData();\n    // },\n    created() {\n      this.async(() => {\n        this._createCanvas();\n      });\n    },\n    observers: ['prepareData(_selectedItem)'],\n    /**\n     * This method has a chain of promises that process the data as needed.\n     * first, we find the selected item inside _calculatePath\n     * secondly, we set the _mainPathItems\n     * thirdly, we figure out the display options - whether we need overflow, shorten any names, etc.\n     * lastly, we set the _mainPathItems again, this time with the shortened/overflow version, \n     * if necessary\n     */\n    prepareData() {\n      this._calculatePath()\n      .then((pathArray) => {\n        return this._breadcrumbsDisplayOptions(pathArray)})\n      .then((pathArray) => {\n        //and the second time this is being set, it's with the shortened versions, if necessary. \n        this.set('_mainPathItems', pathArray);\n      });\n    },\n    _calculateSizeOfBreadcrumbs(strArray, map, useFullSize=true) {\n      if (strArray) {\n        var ctx = this.ctx;\n\n        for (var i=0; i<strArray.length;i++) {\n          var item = map.get(strArray[i]) || {};\n          var thingToMeasure = useFullSize ? strArray[i].text : item.shortText;\n          //console.log(parseInt(ctx.measureText(strArray[i].text).width,10));\n          var sizeOfItem = parseInt(ctx.measureText(thingToMeasure).width,10);\n\n          //if the item has children, we need to the size of the down chevron.\n          if (strArray[i].children) {\n            sizeOfItem += 11;\n          }\n\n          item[useFullSize ? 'fullSize' : 'shortSize'] = sizeOfItem;\n          map.set(strArray[i], item); \n        }\n      }        \n        \n      return map;\n    },\n\n    _calculateAcummSize(items, map, requiredParam) {\n        return items.reduce((accum, item, index) => {\n          if (index !== items.length -1) {\n            accum += 15;\n          }\n          return accum + map.get(item)[requiredParam];\n        },0);\n    },\n    /* \n    * in this method, we decide on the display options for the breadcrumbs. \n    * we have the following options:\n    * 1. nothing needs to be shortened.\n    * 2. we can shorten all but the last one\n    * 2. we can shorten all including the last one\n    * 3. we can shorten all of them, and include the overflow at the beginning of the array. the last one is NOT shortened.\n    * @param {array} strArray an array of objects, which contains the breadcrumbs\n    */\n    _breadcrumbsDisplayOptions(strArray) {\n      return new Promise((accept, reject) => {\n        var ctx = this.ctx,\n            map = new WeakMap(),\n            accumulativeSizeOfAllBreadcrumbs;\n\n        map = this._calculateSizeOfBreadcrumbs(strArray, map, true);\n        \n        accumulativeSizeOfAllBreadcrumbs = this._calculateAcummSize(strArray, map, 'fullSize');\n\n         \n          this.async(() => {\n            //find the container we want to measure.\n            var breadcrumbs = document.querySelector('px-breadcrumbs'),\n                breadcrumbsContainer = Polymer.dom(breadcrumbs.root).querySelector('.container'),\n                breadcrumbsUlContainer = Polymer.dom(breadcrumbsContainer).querySelector('ul'),\n                bcUlContainerRect = breadcrumbsContainer.getBoundingClientRect(),\n                ulWidth = bcUlContainerRect.width + 4; //the 4 is for the padding (2px on each side) on the ul.\n\n               \n            /*\n            * option 1 \n            * we check to see if the container (which is sized automatically to fill out the page)\n            * can fit all the items in the breadcrumbs.\n            * the first option is the simpliest one - everything just fits, but if it doesn't fit...\n            */\n            if (ulWidth < accumulativeSizeOfAllBreadcrumbs) {\n              var allButTheLastItem = strArray.slice(0, strArray.length-1);\n              \n              //these calls add the shortened text strings to the map, as well as the pixel sizes of the shortened\n              //string.\n              map = this._shortenLongAssetNames(strArray, map);\n              map = this._calculateSizeOfBreadcrumbs(strArray, map, false);\n              \n              var sizeOfAllButLastItem = this._calculateAcummSize(allButTheLastItem, map, 'shortSize'),\n                  sizeOfFullLastItem = map.get(strArray[strArray.length-1]).fullSize,\n                  sizeOfShortLastItem = map.get(strArray[strArray.length-1]).shortSize;\n\n              /*\n              * option 2\n              * we want to find out if the container can now fit all of the \n              * shortened items + the last Item  that wasn't shortened\n              */\n              if (ulWidth < sizeOfAllButLastItem + sizeOfFullLastItem) {\n                //it doesn't fit, so, we go to second option.\n              \n                var sizeOfAllShortenedItems = sizeOfAllButLastItem + sizeOfShortLastItem;\n                \n                /*\n                * option 3 \n                * we check if we can fit after we've shortened all the items \n                */\n                if (ulWidth < sizeOfAllShortenedItems) {\n                  //looks like we can't fit them, even after shortening them all. \n                  //time for option 4.\n                  //i'm setting a random high number to start with\n                  var shortenAllItemsWithOverflow = 99999,\n                      pointer = 0,\n                      removedItem,\n                      currentAccumSize = sizeOfAllShortenedItems,\n                      removedAccumSize = 0;\n                  //keep looping until all the items fit into the container\n                  while (ulWidth < currentAccumSize) {\n                    //get the size of the item we are placing into the overflow\n                    var removedSize = map.get(strArray[pointer]).shortSize;\n                    // subtract the size from the overall accumulated size\n                    currentAccumSize -= removedSize;\n                    //and make sure to manually change our pointer.\n                    pointer++;\n                    \n                  }\n\n                  //create the overflow object, and populate its children with the shortened strings (if necessary)\n                  var overflowObj = {\n                    \"text\": \"...\",\n                    //populate children with all the items we took out (from position 0 to the pointer)\n                    \"children\": this._getSmallStrs(strArray.slice(0, pointer), map)\n                  },\n                  //add the overflow obj to the beginning of the slicedStrArray array, and follow it up with all the shortened strings, starting with the point we \n                  // stopped at with the pointer.\n                  slicedStrArray = [overflowObj].concat(this._getSmallStrs(strArray.slice(pointer), map));\n                  \n                  console.log('shorten everything, include overflow');\n                  return accept(slicedStrArray);\n                } else {\n                  /*\n                  * option 3\n                  * we can fit all the breadcrumbs once we've shortened them.\n                  */\n                  console.log('shorten everything fits');\n                  var strArrayShortened = this._getSmallStrs(strArray, map);\n                  return accept(strArrayShortened);\n                }\n              } else {\n                /*\n                * Option 2\n                * shortening everything but the last one works\n                */\n\n                console.log('shorten everything but the last one.');\n                var strArrayShortenedWithFullLastItem = this._getSmallStrs(strArray.slice(0, strArray.length-1),map).concat(strArray.slice(-1));\n                return accept(strArrayShortenedWithFullLastItem);\n              }\n            } else {\n            //everything fits, no need to shorten anything\n            console.log('everything fits off the bat');\n            return accept(strArray);\n          }\n        }, 1500); \n      });\n    },\n    _getSmallStrs(items, map) {\n      debugger;\n      var itemList =  items.map((item) => {\n        item.text = map.get(item).shortText;\n        return item;\n      });\n      debugger;\n      return itemList;\n    },\n    _createCanvas() {\n      var canvas = document.createElement('canvas');\n      canvas.height = 20;\n      canvas.width = 9999;\n      this._measurementCanvas = canvas;\n      var ctx = this._measurementCanvas.getContext('2d');\n      ctx.font = \"15px GE Inspira Sans\";\n      this.set('ctx', ctx) ;\n    },\n    /**\n     * This method accepts the path array, and loops through it recursively\n     * looking for anything with more than 16 characters.\n     * \n     * once it finds a long asset name, it shortens it.\n     * @param {Object} pathArray \n     * @return {Array} PathArray  - the modified array with the shortened names in it.\n     */\n    _shortenLongAssetNames(pathArray, map) {\n\n      //loop through each item\n        for (var i=0, len = pathArray.length; i<len;i++) {\n\n            var item = map.get(pathArray[i]) || {};\n\n            //either save the shortened version, or the full version of the text\n            item.shortText = (pathArray[i].text.length > 16) ? this._returnShortenString(pathArray[i].text) : pathArray[i].text;\n            \n            map.set(pathArray[i], item);\n\n          //make sure to search through the children as well by calling this recursively\n          if (pathArray[i].children) {\n            this._shortenLongAssetNames(pathArray[i].children, map);\n          }\n      }\n      //once we're done, return with the modified map\n      return map;\n       \n    },\n    /**\n     * This method accepts an obj that has more than 16 characters in its text, and \n     * returns the shortened version of that text.\n     * @param {Obj} pathItem \n     * @return {Promise} shortenedString\n     */\n    _returnShortenString(itemText) {\n        var beginning = itemText.substr(0,6),\n        middle = \"...\",\n        end = itemText.substr(itemText.length-6);\n        return beginning + middle + end;\n    },\n    /**\n     * This method is used to determine where the path click came from - we have 3 different options, \n     * 1. the text\n     * 2. the down chevron\n     * 3. The side chevron\n     * but we really want the encompossing LI, regardless of what was clicked. \n     * the two icons have a _iconsetName property that is 'fa' so we use that to determine if they were clicked, \n     * and if so, grab their parent, which is the LI.\n     * @param {*} evt the event generated by the user tap\n     */\n    _normalizePathClickTarget(evt) {\n      return (evt.target._iconsetName === 'fa') ? evt.target.parentNode.parentNode : evt.target;\n    },\n    /**\n     * This method resets the existing _selectedItem\n     */\n    _resetSelectedItem() {\n      this.set('_selectedItem', false);\n    },\n    /**\n     * This method is called on load, to calculate the initial Path, \n     * everytime a breadcrumb is clicked.\n     * it recursively builds the path, and returns it as a promise.\n     */\n    _calculatePath() {\n      return new Promise((accept, reject) => {\n        var pathArray = [],\n        currentDataObj = this.breadcrumbData,\n        self = this,\n        foundSelectedItem = false;\n        var recursiveLoopThroughObj = function(pathItem) {\n          for (var i=0, len = pathItem.length; i<len;i++) {\n            if (foundSelectedItem) {\n              break;\n            };\n\n            if (pathItem[i].selectedItem) {\n                pathArray.push(pathItem[i]);\n                foundSelectedItem = true;\n                break;\n              }\n\n            if (pathItem[i].children) {\n              //if it has children, we want to keep digging in\n              //so we push the item we are on into the pathArray\n              //and call ourselves with the children of the current item\n              pathArray.push(pathItem[i]);\n              recursiveLoopThroughObj(pathItem[i].children)\n            }\n          }\n        };\n\n        //the initial call into the recursion\n        recursiveLoopThroughObj(currentDataObj);\n\n        //once all the recursion is done, we can return the pathArray\n        return accept(pathArray);\n      });\n    },\n   \n    /**\n     * This function checks whether the item in question has children.\n     * @param {*} itemInPath \n     */\n    _doesItemHaveChildren(itemInPath) {\n      return (itemInPath && itemInPath.hasChildren);\n    },\n    /**\n     * This function is used to determine whether we are on the last Item in the array. - if \n     * the index is the last item in the aray (length -1), we return false.\n     * @param {Number} index the index of the item\n     */\n    _isLastItemInData(index) {\n      return this._mainPathItems[this._mainPathItems.length-1] === this._mainPathItems[index];\n    },\n    /**\n     * This function is used to determine the correct classes that need to be passed in - if \n     * the index is the last item in the aray, we want it to be bold, so we pass the selected class.\n     * \n     * @param {Number} index This represents the index of the item we are looking at in the array.\n     */\n    _calculatePathclass(index) {\n      return this._isLastItemInData(index) ? ' selected' : '';\n    },\n    /**\n     * this method calls a reset on whatever selected Item we \n     * previously had, and calls a set on the new selectedItem \n     * @param {Object} evt the click event from the dropdown item clicked\n     */\n    _dropdownTap(evt) {\n      this._resetSelectedItem();\n      var newSelectItem = evt.model.item;\n      this._setSelectedItem(newSelectItem);\n      //this hides the dropdown\n      this.set('_isDropdownHidden', true);\n      this._changePathFromDropdownClick();\n      //and this clears out the field that hold the previously clicked\n      //path item.\n      this.set('_clickPathItem', {});\n      \n    },\n    /**\n     * This method calls the prepareData method, which runs through the \n     */\n    _changePathFromDropdownClick() {\n      this.prepareData();\n    },\n    /**\n     * This method sets a _selectedItem from the passed object.\n     * @param {Object} selectedItem the new selected item\n     */\n    _setSelectedItem(selectedItem) {\n      selectedItem.selectedItem = true;\n      this.set('_selectedItem', selectedItem);\n    },\n    _onPathTap(evt) {\n      var dataItem = evt.model.item;\n\n      /* on tap, we need to find out if the clicked item is the same as before.\n      * if it is, we make the dropdown go way.\n      * if it is not, we save the new clicked item.\n      */\n\n      // if the selected item (the one at the end of the breadcrumb) has been clicked, ignore it.\n      if (evt.model.item.selectedItem) {\n        evt.stopPropagation();\n        return;\n      }\n      //if the item that is clicked is the open option, hide the dropdown, and reset the _clickPathItem object.\n      if (this._clickPathItem === dataItem) {\n        this.set('_isDropdownHidden', true);\n        this.set('_clickPathItem', {});\n      } else {\n        //new click on new item, set the clicked item, show the dropdown and set its position.\n        this.set('_clickPathItem', dataItem);\n        this.set('_isDropdownHidden', false);\n        this._changeDropdownPosition(evt);\n      }\n      if (this._doesItemHaveChildren(dataItem)) {\n        //dataItem.children = shortenedVersion(dataItem.children)\n        this.set('_clickedItemChildren', dataItem.children);\n      }\n    },\n    /**\n     * @param {Object} positioning an object which holds the new positioning for the dropdown\n     */\n    _changeDropdownPosition(evt) {\n      var normalizedTarget = this._normalizePathClickTarget(evt),\n          targetRect = normalizedTarget.getBoundingClientRect(),\n          targetLeft = targetRect.left,\n          targetBottom = targetRect.bottom,\n          targetHeight = targetRect.height,\n          windowScrollX = window.scrollX,\n          windowScrollY = window.scrollY,\n          dropdown = Polymer.dom(this.root).querySelector('.breadCrumbdropdown');\n      \n      dropdown.style.top = (targetBottom + windowScrollY + 4) + 'px';\n      dropdown.style.left = targetLeft + windowScrollX + 'px';\n    },\n    /**\n     * This method dispatches a custom event ('px-breadcrumbs-item-clicked') that has the item attached to it.\n     * the 'composed: true' property makes it so the event passes through shadow dom boundaries.\n     * @param {*} item the item that was clicked on.\n     */\n    _notifyClick(item) {\n      this.dispatchEvent(new CustomEvent('px-breadcrumbs-item-clicked', {item: item, composed: true}));\n    }\n  });\n})();\n"]}