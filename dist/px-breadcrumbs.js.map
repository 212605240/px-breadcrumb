{"version":3,"sources":["px-breadcrumbs.es6.js"],"names":["Polymer","is","properties","breadcrumbData","type","Array","value","_mainPathItems","_clickPathItem","Object","_clickedItemChildren","_isDropdownHidden","Boolean","_selectedItem","observers","_normalizePathClickTarget","evt","target","_iconsetName","parentNode","_resetSelectedItem","selectedItem","_calculatePath","pathArray","currentDataObj","self","foundSelectedItem","console","log","set","recursiveLoopThroughObj","pathItem","i","len","length","push","children","_doesItemHaveChildren","itemInPath","hasChildren","_isNotLastItemInData","index","_calculatePathclass","_dropdownTap","newSelectItem","model","item","_setSelectedItem","_onPathTap","dataItem","stopPropagation","_changeDropdownPosition","extractClickedPathItemPosition","clickedItem","normalizedTarget","targetRect","getBoundingClientRect","targetLeft","left","targetBottom","bottom","targetHeight","height","windowScrollX","window","scrollX","windowScrollY","scrollY","dropdown","dom","root","querySelector","style","top","_notifyClick","dispatchEvent","CustomEvent","composed"],"mappings":"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","file":"px-breadcrumbs.js","sourcesContent":["(function() {\n  Polymer({\n\n    is: 'px-breadcrumbs', \n\n    properties: {\n      /**\n       * This array receives/holds the data that will be transformed into the breadcrumbs.\n       */\n      breadcrumbData: {\n        type: Array,\n        value: function() {return [];}\n      },\n      _mainPathItems: {\n        type: Array,\n        value: function() {return [];}\n      },\n      _clickPathItem: {\n        type: Object,\n        value: function() {return {};}\n      },\n      _clickedItemChildren: {\n        type: Array,\n        value: function() {return [];},\n        \n      },\n      _isDropdownHidden: {\n        type: Boolean,\n        value: true\n      },\n      _selectedItem: {\n        type: Object,\n        value: function() {return {};}\n      }\n    },\n    observers: ['_calculatePath(breadcrumbData.*, _selectedItem)'],\n    /**\n     * This method is used to determine where the path click came from - we have 3 different options, \n     * 1. the text\n     * 2. the down chevron\n     * 3. The side chevron\n     * but we really want the encompossing LI, regardless of what was clicked. \n     * the two icons have a _iconsetName property that is 'fa' so we use that to determine if they were clicked, \n     * and if so, grab their parent, which is the LI.\n     * @param {*} evt the event generated by the user tap\n     */\n    _normalizePathClickTarget(evt) {\n      return (evt.target._iconsetName === 'fa') ? evt.target.parentNode.parentNode : evt.target;\n    },\n    /**\n     * This method resets the existing _selectedItem\n     */\n    _resetSelectedItem() {\n      this._selectedItem.selectedItem = false;\n    },\n    /**\n     * This method is called on load, to calculate the initial Path, \n     * everytime a breadcrumb is clicked.\n     * it recursively builds the path, while looking for the \n     * selectedItem.\n     */\n    _calculatePath() {\n      var pathArray = [],\n      currentDataObj = this.breadcrumbData,\n      self = this,\n      foundSelectedItem = false;\n      console.log('_calculatePath');\n      this.set('_mainPathItems',[]);\n      var recursiveLoopThroughObj = function(pathItem) {\n        for (var i=0, len = pathItem.length; i<len;i++) {\n          console.log('pathItem[i] = ');\n          console.log(pathItem[i]);\n          if (foundSelectedItem) {\n            break;\n          };\n\n          if (pathItem[i].selectedItem) {\n              pathArray.push(pathItem[i]);\n              self.set('_selectedItem', pathItem[i]);\n              foundSelectedItem = true;\n              break;\n            }\n\n          if (pathItem[i].children) {\n            //if it has children, we want to keep digging in\n            //so we push the item we are on into the pathArray\n            //and call ourselves with the children of the current item\n            pathArray.push(pathItem[i]);\n            recursiveLoopThroughObj(pathItem[i].children)\n          }\n        }\n      };\n\n      //the initial call into the recursion\n      recursiveLoopThroughObj(currentDataObj);\n\n      //once all the recursion is done, we can set the value of \n      //_mainPathItems\n      this.set('_mainPathItems', pathArray);\n    },\n   \n    /**\n     * This function checks whether the item in question has children.\n     * @param {*} itemInPath \n     */\n    _doesItemHaveChildren(itemInPath) {\n      return itemInPath.hasChildren;\n    },\n    /**\n     * This function is used to determine whether we are on the last Item in the array. - if \n     * the index is the last item in the aray (length -1), we return false.\n     * @param {*} index \n     */\n    _isNotLastItemInData(index) {\n      return this._mainPathItems.length-1 !== index;\n    },\n    /**\n     * This function is used to determine the correct classes that need to be passed in - if \n     * the index is the last item in the aray, we want it to be bold, so we pass the selected class.\n     * \n     * @param {*} index This represents the index of the item we are looking at in the array.\n     */\n    _calculatePathclass(index) {\n      return !this._isNotLastItemInData(index) ?  ' selected' : '';\n    },\n    /**\n     * this method call a reset on whatever selected Item we \n     * previously had, and call a set on the new selectedItem \n     * @param {*} evt the click event from the dropdown item clicked\n     */\n    _dropdownTap(evt) {\n      this._resetSelectedItem();\n      console.log(evt);\n      var newSelectItem = evt.model.item;\n      this._setSelectedItem(newSelectItem);\n      //this hides the dropdown\n      this.set('_isDropdownHidden', true);\n      //and this clears out the field that hold the previously clicked\n      //path item.\n      this.set('_clickPathItem', {});\n    },\n    /**\n     * This method sets a _selectedItem set from the passed object.\n     * @param {Object} selectedItem the new selected item\n     */\n    _setSelectedItem(selectedItem) {\n      selectedItem.selectedItem = true;\n      this.set('_selectedItem', selectedItem);\n      console.log(selectedItem);\n    },\n    _onPathTap(evt) {\n      console.log('path click');\n      var dataItem = evt.model.item;\n      /* on tap, we need to find out if the clicked item is the same as before.\n      * if it is, we make the dropdown go way.\n      * if it is not, we save the new clicked item.\n      */\n\n      // if the selected item (the one at the end of the breadcrumb) has been clicked, ignore it.\n      if (evt.model.item.selectedItem) {\n        evt.stopPropagation();\n        return;\n      }\n      if (this._clickPathItem === dataItem) {\n        console.log('this._clickPathItem === evt.model.item');\n        this.set('_isDropdownHidden', true);\n        this.set('_clickPathItem', {});\n      } else {\n        console.log('else');\n        this.set('_clickPathItem', dataItem);\n        this.set('_isDropdownHidden', false);\n        this._changeDropdownPosition(evt);\n      }\n      // 1. Check if there are children. \n\n      if (this._doesItemHaveChildren(dataItem)) {\n        this.set('_clickedItemChildren', dataItem.children);\n      }\n      \n      \n        // a. If there are kids, we need to update clickedItemChildren. \n        // b. If not, we fire an event that the clicked on item is the selected context.\n      // 2. If there are children, we need to find the left/top/height of the clicked item, and calculate the positioning of the dropdown accordingly \n    },\n    \n    /**\n     * \n     * @param {Object} clickedItem the clicked item\n     * @return Object that holds the calculated top/left for the dropdown.\n     */\n    extractClickedPathItemPosition(clickedItem) {\n      //TODO extract top/left/height from clickedItem.\n      // then, calculate the new positioning, and save it into an object.\n      // returns an object that holds the new top/left positioning.\n    },\n    /**\n     * \n     * @param {Object} positioning an object which holds the new positioning for the dropdown\n     */\n    _changeDropdownPosition(evt) {\n      var normalizedTarget = this._normalizePathClickTarget(evt),\n          targetRect = normalizedTarget.getBoundingClientRect(),\n          targetLeft = targetRect.left,\n          targetBottom = targetRect.bottom,\n          targetHeight = targetRect.height,\n          windowScrollX = window.scrollX,\n          windowScrollY = window.scrollY,\n          dropdown = Polymer.dom(this.root).querySelector('.breadCrumbdropdown');\n      console.log(targetRect);\n      dropdown.style.top = (targetBottom + windowScrollY + 4) + 'px';\n      dropdown.style.left = targetLeft + windowScrollX + 'px';\n      \n    },\n    /**\n     * This method dispatches a custom event ('px-breadcrumbs-item-clicked') that has the item attached to it.\n     * the 'composed: true' property makes it so the event passes through shadow dom boundaries.\n     * @param {*} item the item that was clicked on.\n     */\n    _notifyClick(item) {\n      //TODO fire an event with the clicked on item.\n      this.dispatchEvent(new CustomEvent('px-breadcrumbs-item-clicked', {item: item, composed: true}));\n    }\n  });\n})();\n"]}